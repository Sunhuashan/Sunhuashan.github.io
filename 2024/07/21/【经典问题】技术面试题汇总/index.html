<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="这篇文章是用来总结 C&#x2F;C++ 开发校招面试的笔记汇总，内容主要会涉及操作系统，计算机网络，计算机组成原理，编程语言，Linux，Git，多线程，数据结构与算法等等。这篇文章会持续更新，用作复习阶段的知识点梳理，也用作面试前的快速回顾。">
<meta property="og:type" content="article">
<meta property="og:title" content="【经典问题】技术面试题汇总">
<meta property="og:url" content="http://example.com/2024/07/21/%E3%80%90%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E3%80%91%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/index.html">
<meta property="og:site_name" content="sunhuashan">
<meta property="og:description" content="这篇文章是用来总结 C&#x2F;C++ 开发校招面试的笔记汇总，内容主要会涉及操作系统，计算机网络，计算机组成原理，编程语言，Linux，Git，多线程，数据结构与算法等等。这篇文章会持续更新，用作复习阶段的知识点梳理，也用作面试前的快速回顾。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/imgs/%E3%80%90%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E3%80%91%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/image-20240726085124985.png">
<meta property="og:image" content="http://example.com/imgs/%E3%80%90%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E3%80%91%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/image-20240726085151116.png">
<meta property="og:image" content="http://example.com/imgs/%E3%80%90%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E3%80%91%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/image-20240808142127702.png">
<meta property="og:image" content="http://example.com/imgs/%E3%80%90%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E3%80%91%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/image-20240801164404729.png">
<meta property="og:image" content="http://example.com/imgs/%E3%80%90%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E3%80%91%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/image-20240802092625556.png">
<meta property="og:image" content="http://example.com/imgs/%E3%80%90%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E3%80%91%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/image-20240802092935206.png">
<meta property="og:image" content="http://example.com/imgs/%E3%80%90%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E3%80%91%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/image-20240801084207363.png">
<meta property="og:image" content="http://example.com/imgs/%E3%80%90%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E3%80%91%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/image-20240801112249259.png">
<meta property="og:image" content="http://example.com/imgs/%E3%80%90%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E3%80%91%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/image-20240801113032935.png">
<meta property="og:image" content="http://example.com/imgs/%E3%80%90%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E3%80%91%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/image-20240801103914121.png">
<meta property="og:image" content="http://example.com/imgs/%E3%80%90%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E3%80%91%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/image-20240801114559664.png">
<meta property="og:image" content="https://kqa3yyvhjg0.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2E4ZjIxN2I0YTIxZmYyMzI5NGRjMDA3NmI0NjdjMDhfV0p2b2tlRG5CMEdGOEg0a3ppS1JsNVNVTEpNWkVkOE9fVG9rZW46SkNkZ2JGUkhIb0Z3bjh4Z3JqSGNSNmNIbnZmXzE3MjYyMjA2NjI6MTcyNjIyNDI2Ml9WNA">
<meta property="og:image" content="https://kqa3yyvhjg0.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDYxZTg0NjUzYTc4Yzg2OWVmMDhlMmRkYTY5YmU4YzZfbTVERDM1MzdwbWRHWTVxSjNUVng3M2d2Z2loczRwQUhfVG9rZW46TDhibGJhc0FGb1VNRDR4aTFwMmNUY29xbm9kXzE3MjYyMjA2NjI6MTcyNjIyNDI2Ml9WNA">
<meta property="og:image" content="https://kqa3yyvhjg0.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2QzYWM3NzhlZWI0MDEzYTEwNWI4MWY1ZThmZDc4MmVfbjIzWjY2SmNMMG5TSlBhYWgwbmVHakhhRVZIMkxxaE1fVG9rZW46RVlUN2JBT1Ywb0JnSDd4MVlzOWNWd3hublRjXzE3MjYyMjA2NjI6MTcyNjIyNDI2Ml9WNA">
<meta property="article:published_time" content="2024-07-21T09:05:03.000Z">
<meta property="article:modified_time" content="2024-09-13T09:45:07.731Z">
<meta property="article:author" content="sunhuashan">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/imgs/%E3%80%90%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E3%80%91%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/image-20240726085124985.png">

<link rel="canonical" href="http://example.com/2024/07/21/%E3%80%90%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E3%80%91%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>【经典问题】技术面试题汇总 | sunhuashan</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">sunhuashan</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/21/%E3%80%90%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E3%80%91%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jfif">
      <meta itemprop="name" content="sunhuashan">
      <meta itemprop="description" content="唯天下之至拙能胜天下之至巧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sunhuashan">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【经典问题】技术面试题汇总
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-21 17:05:03" itemprop="dateCreated datePublished" datetime="2024-07-21T17:05:03+08:00">2024-07-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>这篇文章是用来总结 C&#x2F;C++ 开发校招面试的笔记汇总，内容主要会涉及操作系统，计算机网络，计算机组成原理，编程语言，Linux，Git，多线程，数据结构与算法等等。这篇文章会持续更新，用作复习阶段的知识点梳理，也用作面试前的快速回顾。</p>
<span id="more"></span>

<ul>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a><ul>
<li><a href="#%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81">用户态和内核态</a><ul>
<li><a href="#%E5%86%85%E6%A0%B8%E6%80%81%E5%92%8C%E7%94%A8%E6%88%B7%E6%80%81%E7%9A%84%E5%8C%BA%E5%88%AB">内核态和用户态的区别?</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E9%99%B7%E5%85%A5%E5%86%85%E6%A0%B8%E6%80%81">什么时候会陷入内核态?</a></li>
<li><a href="#C-%E8%AE%BF%E9%97%AE%E7%A9%BA%E6%8C%87%E9%92%88%E4%BC%9A%E4%B8%8D%E4%BC%9A%E9%99%B7%E5%85%A5%E5%86%85%E6%A0%B8%E6%80%81%EF%BC%9F">C 访问空指针会不会陷入内核态？</a></li>
</ul>
</li>
<li><a href="#%E9%99%B7%E9%98%B1%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E4%BF%A1%E5%8F%B7">陷阱、中断、异常、信号</a><ul>
<li><a href="#%E9%99%B7%E9%98%B1%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%A6%82%E5%BF%B5">陷阱、中断、异常、信号的概念</a></li>
<li><a href="#%E9%99%B7%E9%98%B1%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B">陷阱、中断、异常、信号的处理流程</a></li>
<li><a href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E9%99%B7%E9%98%B1%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E4%BF%A1%E5%8F%B7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">常见的陷阱、中断、异常、信号有哪些？</a></li>
<li><a href="#Ctrl--C%E3%80%81Ctrl--Z%E3%80%81kill-%E3%80%81kill--9-%E7%9A%84%E5%8E%9F%E7%90%86"><code>Ctrl + C</code>、<code>Ctrl + Z</code>、<code>kill</code> 、<code>kill -9</code> 的原理</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B">进程与线程</a><ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB">进程与线程的区别</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%EF%BC%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2">线程，进程的上下文切换</a></li>
<li><a href="#%E6%B6%89%E5%8F%8A%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C">涉及内核线程的上下文切换有什么不同</a></li>
<li><a href="#switch_to-%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0">switch_to 函数为什么需要三个参数</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F">进程与线程的通信方式</a><ul>
<li><a href="#%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6">信号机制</a></li>
<li><a href="#%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93">匿名管道</a></li>
<li><a href="#%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93">命名管道</a></li>
<li><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8F">信号量</a></li>
<li><a href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98">共享内存</a></li>
<li><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">消息队列</a></li>
<li><a href="#%E5%A5%97%E6%8E%A5%E5%AD%97-socket">套接字 socket</a></li>
<li><a href="#%E5%90%84%E7%A7%8D-IPC-%E9%80%82%E7%94%A8%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF">各种 IPC 适用什么场景</a></li>
<li><a href="#%E8%A6%81%E6%B1%82%E8%BF%9B%E7%A8%8B%E5%B4%A9%E6%BA%83%E9%87%8D%E5%90%AF%E5%90%8E%E5%8F%AF%E4%BB%A5%E7%BB%A7%E7%BB%AD%E8%AF%BB%E5%86%99%EF%BC%8C%E8%AF%A5%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1-IPC-%E6%96%B9%E5%BC%8F">要求进程崩溃重启后可以继续读写，该如何设计 IPC 方式</a></li>
</ul>
</li>
<li><a href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E6%80%81">并发与竞态</a><ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%8C%E4%B8%BE%E4%B8%AA%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E4%BE%8B%E5%AD%90">什么是线程安全，举个不安全的例子</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E6%B3%95">线程同步的方法</a></li>
<li><a href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%E3%80%81%E5%8F%88%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B">何时使用多进程、又何时使用多线程</a></li>
<li><a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84-error-%E4%BC%9A%E6%9C%89%E9%97%AE%E9%A2%98%E5%90%97">多线程下的 error 会有问题吗</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">计算机网络</a><ul>
<li><a href="#%E4%B8%A4%E5%8F%B0%E4%B8%BB%E6%9C%BA%E9%97%B4%E7%9A%84-TCP-%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B">两台主机间的 TCP 通信过程</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E5%87%BA%E7%8E%B0%E7%BD%91%E9%A1%B5%E7%9A%84%E8%BF%87%E7%A8%8B">输入网址到出现网页的过程</a></li>
<li><a href="#TCP">TCP</a><ul>
<li><a href="#TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B">TCP 三次握手的过程</a></li>
<li><a href="#TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B">TCP 四次挥手的过程</a></li>
<li><a href="#TCP-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">TCP 如何进行流量控制</a></li>
<li><a href="#TCP-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">TCP 如何进行拥塞控制</a></li>
</ul>
</li>
<li><a href="#UDP">UDP</a><ul>
<li><a href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-UDP-%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93">如何使用 UDP 实现可靠传输</a></li>
</ul>
</li>
<li><a href="#TCP-vsUDP">TCP v.s.UDP</a><ul>
<li><a href="#TCP-%E5%92%8C-DUP-%E7%9A%84%E5%8C%BA%E5%88%AB">TCP 和 DUP 的区别</a></li>
<li><a href="#UDP-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94-TCP-%E5%BF%AB">UDP 为什么比 TCP 快</a></li>
</ul>
</li>
<li><a href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B">网络编程</a><ul>
<li><a href="#socket-%E4%B8%AD%E5%90%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%AF%B9%E5%BA%94%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%AA%E4%BA%9B%E8%A1%8C%E4%B8%BA">socket 中各函数，对应客户端和服务器哪些行为</a></li>
<li><a href="#socket-%E9%80%9A%E4%BF%A1%E6%97%B6%EF%BC%8C%E8%BF%9B%E7%A8%8B%E5%B4%A9%E6%BA%83%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88">socket 通信时，进程崩溃会发生什么</a></li>
<li><a href="#socket-%E8%AF%BB%E5%86%99%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%E7%BC%93%E5%86%B2%E5%8C%BA%E7%A9%BA%E6%BB%A1%E8%BF%98%E6%98%AF%E8%BF%9E%E6%8E%A5%E5%B7%B2%E6%96%AD%E5%BC%80">socket 读写如何区分缓冲区空&#x2F;满还是连接已断开</a></li>
<li><a href="#epoll-%E6%AF%94-select-%E9%AB%98%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0">epoll 比 select 高效的原因</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-LT-%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91%EF%BC%8C%E7%9B%91%E5%90%AC%E5%A4%9A%E4%B8%AA%E5%86%99%E4%BA%8B%E4%BB%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%86%99%E5%B0%B1%E7%BB%AA%E5%90%8E-epoll_wait-%E4%B8%8B%E4%B8%80%E6%AC%A1%E4%B8%8D%E8%BF%94%E5%9B%9E">使用 LT 水平触发，监听多个写事件，如何保证写就绪后 epoll_wait 下一次不返回</a></li>
<li><a href="#epoll-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E5%81%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">epoll 为什么使用红黑树做数据结构</a></li>
<li><a href="#%E6%8F%8F%E8%BF%B0%E4%BD%BF%E7%94%A8-epoll-%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%B0%83%E7%94%A8-api-%E7%9A%84%E6%B5%81%E7%A8%8B">描述使用 epoll 实现服务端调用 api 的流程</a></li>
<li><a href="#sendfile-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98">sendfile 系统调用解决的问题</a></li>
</ul>
</li>
<li><a href="#%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8">工具使用</a><ul>
<li><a href="#gdb-%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%E6%8C%87%E4%BB%A4">gdb 用过哪些指令</a></li>
<li><a href="#uboot-%E7%9A%84%E5%90%AF%E5%8A%A8%E7%9A%84%E5%A4%A7%E8%87%B4%E6%B5%81%E7%A8%8B">uboot 的启动的大致流程</a></li>
<li><a href="#CPU-%E5%8D%A0%E7%94%A8%E7%8E%87%E8%BF%87%E9%AB%98%EF%BC%8C%E5%A6%82%E4%BD%95%E6%9F%A5%E5%8E%9F%E5%9B%A0">CPU 占用率过高，如何查原因</a></li>
<li><a href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5%E6%88%96%E9%81%BF%E5%85%8D">内存泄漏如何检查或避免</a></li>
</ul>
</li>
<li><a href="#CC">C&#x2F;C++</a></li>
</ul>
</li>
</ul>
<!-- TOC --><a name="-1"></a>

<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><!-- TOC --><a name="-2"></a>
<h3 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h3><!-- TOC --><a name="-3"></a>
<h4 id="内核态和用户态的区别"><a href="#内核态和用户态的区别" class="headerlink" title="内核态和用户态的区别?"></a>内核态和用户态的区别?</h4><p>最简单的运行程序的方式是“直接执行”，即直接在 CPU 上执行任意程序。直接执行的问题是：</p>
<ol>
<li>如何限制代码行为？比如禁止：设置特殊寄存器的值、访问存储器的任意位置、I&#x2F;O 请求、申请更多系统资源等</li>
<li>在运行这个程序的时候，如何切换到另一个程序？进程调度应该是 OS 才有的权限</li>
</ol>
<p>因此引入用户态和内核态和两种模式。用户态无法执行受限操作，如 I&#x2F;O 请求，执行这些操作会引发异常。核心态只能由操作系统运行，可以执行特权操作。用户程序通过<strong>系统调用</strong> system call 执行这些特权操作。OS 执行前会判断进程是否有<strong>权限</strong>执行相应的指令。</p>
<p>区分用户态和核心态的执行机制称为“受限直接执行”（Limited Direct Execution）。</p>
<!-- TOC --><a name="-4"></a>
<h4 id="什么时候会陷入内核态"><a href="#什么时候会陷入内核态" class="headerlink" title="什么时候会陷入内核态?"></a>什么时候会陷入内核态?</h4><p>系统调用（trap）、中断（interrupt）和异常（exception）。</p>
<p>系统调用是用户进程主动发起的操作。发起系统调用，陷入内核，由操作系统执行系统调用，然后再返回到进程。</p>
<p>中断和异常是被动的，无法预测发生时机。中断包括 I&#x2F;O 中断、外部信号中断、各种定时器引起的时钟中断等。异常包括程序运算引起的各种错误如除 0、缓冲区溢出、缺页等。</p>
<p>在系统的处理上，中断和异常类似，都是通过中断向量表来找到相应的处理程序进行处理。区别在于，中断来自处理器外部，不是由任何一条专门的指令造成，而异常是执行当前指令的结果。</p>
<!-- TOC --><a name="c-"></a>

<h4 id="C-访问空指针会不会陷入内核态？"><a href="#C-访问空指针会不会陷入内核态？" class="headerlink" title="C 访问空指针会不会陷入内核态？"></a>C 访问空指针会不会陷入内核态？</h4><p>会。</p>
<p>访问指针相当于访问一个虚拟地址，硬件会将虚拟地址映射到真实的物理内存。如果映射失败，硬件会抛出一个段错误<strong>异常</strong>（page fault exception），此时会<strong>从用户态转为内核态</strong>进行处理。</p>
<p>OS 会在中断描述符表中，找到处理 page fault exception 的中断向量，执行相应的 handler。一般情况下，OS 会抛出一个 <code>SIGSEGV</code> 信号给进程，中止进程，打印出 debug 信息。</p>
<!-- TOC --><a name="-5"></a>
<h3 id="陷阱、中断、异常、信号"><a href="#陷阱、中断、异常、信号" class="headerlink" title="陷阱、中断、异常、信号"></a>陷阱、中断、异常、信号</h3><!-- TOC --><a name="-6"></a>
<h4 id="陷阱、中断、异常、信号的概念"><a href="#陷阱、中断、异常、信号的概念" class="headerlink" title="陷阱、中断、异常、信号的概念"></a>陷阱、中断、异常、信号的概念</h4><p><strong>陷阱</strong> </p>
<p>陷阱是<strong>有意</strong>造成的“异常”，是执行一条指令的结果。陷阱是同步的。</p>
<p>陷阱的主要作用是实现<strong>系统调用</strong>。比如，进程可以执行 <code>syscall n</code> 指令向内核请求服务。当进程执行这条指令后，会中断当前的控制流，<strong>陷入</strong>到内核态，执行相应的系统调用。内核的处理程序在执行结束后，会将结果返回给进程，同时退回到用户态。进程此时继续执行<strong>下一条指令</strong>。</p>
<p>每个系统调用有一个唯一的整数号，对应于内核中一个跳转表的偏移量。这个跳转表中的每个条目表示一个系统调用的代码位置。执行系统调用时，通过这个整数号作为跳转表的偏移量，就可以执行相应的系统调用。</p>
<p><strong>中断</strong> </p>
<p>中断由处理器<strong>外部</strong>的<strong>硬件</strong>产生，不是执行某条指令的结果，也无法预测发生时机。由于中断独立于当前执行的程序，因此中断是异步事件。</p>
<p>中断包括 I&#x2F;O 设备发出的 I&#x2F;O 中断、各种定时器引起的时钟中断、调试程序中设置的断点等引起的调试中断等。</p>
<p>每个中断都有一个中断号。操作系统使用<strong>中断描述符表</strong>（Interrupt Descriptor Table，IDT）来保存每个中断的中断处理程序的地址。当发生中断时，操作系统会根据中断号，在中断描述表中查找并执行相应的中断处理程序。当处理程序返回后，进程继续执行<strong>下一条指令</strong>，就好像没有发生过中断一样。</p>
<p><strong>异常</strong> </p>
<p>异常是一种错误情况，是执行当前指令的结果，可能被错误处理程序修正，也可能直接终止应用程序。异常是同步的。</p>
<p>这里的“异常”特指因为执行当前指令而产生的<strong>错误情况</strong>，比如除法异常、缺页异常等。有些书上也将这类“异常”称为<strong>“故障”</strong>。</p>
<p>当发生异常时，操作系统会将控制转移给相应的异常处理程序。如果处理程序能够修正这个错误情况，就将返回到<strong>引起异常的指令</strong>重新执行。否则，<strong>终止</strong>该应用程序。</p>
<p>异常处理程序的地址也保存在中断描述符表（IDT）中。</p>
<p><strong>信号</strong> </p>
<p>信号是一种<strong>更高层的</strong>软件形式的异常，同样会中断进程的控制流，可以由进程进行处理。一个信号代表了一个消息。信号的作用是用来<strong>通知进程</strong>发生了某种系统事件。</p>
<p>上文的陷阱、中断和异常都是低层异常机制，由内核的异常处理程序进行处理，正常情况下对用户进程是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。</p>
<h4 id="陷阱、中断、异常、信号的处理流程"><a href="#陷阱、中断、异常、信号的处理流程" class="headerlink" title="陷阱、中断、异常、信号的处理流程"></a>陷阱、中断、异常、信号的处理流程</h4><p>陷阱&#x2F;系统调用的处理流程：</p>
<ul>
<li><strong>库函数</strong>：首先在用户空间，库函数会装配系统调用号和参数到指定寄存器中，然后执行特殊指令(svc &#x2F; int 80)陷入内核</li>
<li><strong>特殊指令</strong>：上面的特殊指令处理陷入内核外，可能还会有一些附带的工作，如保存返回地址，切换系统状态，从用户栈切换到内核栈等</li>
<li>内核<strong>保存用户上下文</strong>：进入内核后，内核会保存可能会修改的寄存器到内核栈上，这是为了能够恢复系统调用执行前的用户执行状态必须做的</li>
<li>内核找到<strong>调用入口</strong>：接着，内核会检查系统调用的参数是否合法，并根据系统调用号和系统调用表找到指定系统调用的入口，装配好调用参数后跳转到具体系统调用</li>
<li><strong>返回</strong>：系统调用函数完成指定功能后，会将结果保存到指定寄存器中，然后恢复用户上下文，</li>
</ul>
<p>中断的处理流程（异常也是类似的）：</p>
<p><strong>中断产生</strong> ：与系统调用不同的是，中断是异步发生的，CPU 并不知道何时会发生中断，这是由外设在就绪时主动告诉 CPU 的，CPU 会在每执行完一条指令后去检查中断信号。</p>
<p><strong>栈的切换</strong> ：产生中断后，系统会切换当前程序使用的栈（在 Linux 内核中，可将中断内核栈分开）</p>
<p><strong>保存线程</strong> ：和系统调用类似，为了后面的恢复，这里需要保存当前 CPU 上下文</p>
<p><strong>中断服务程序</strong> ：根据不同的中断，系统会在中断向量表中，找到中断服务程序的入口，并执行中断服务程序</p>
<p><strong>恢复现场</strong> ：执行完中断服务程序后，将之前保存的寄存器出栈，恢复到寄存器上，复原运行环境</p>
<p>信号的处理流程：</p>
<p><strong>信号的发送</strong>：使用 <code>kill</code> 程序可以在 shell 中发送信号；使用 <code>kill</code> 系统调用可以在程序中发送信号</p>
<p><strong>信号的接收</strong> ：每个进程有一个待处理信号的集合。待处理信号表示发送给该进程但是还未被处理（接收）的信号，任何时刻同一类型的待处理信号最多只有一个，后续发送的同类型信号将会被丢弃（隐式阻塞）。</p>
<p><strong>信号的处理</strong> </p>
<p>信号的处理时机：</p>
<ul>
<li>当内核把进程<strong>从内核态切换到用户态时</strong>。例如，从系统调用返回，或是完成一次上下文切换</li>
<li>内核通过<strong>控制转移</strong>来强制进程<em>接收&#x2F;处理</em>信号。如果进程的未被阻塞的待处理信号集合不为空，则内核会选择集合中的某个信号（通常是最小的），并将控制传递到信号处理程序；否则，内核正常地将控制传递到进程的下一条指令</li>
</ul>
<p>用户进程对信号的处理过程有三种：</p>
<ol>
<li><p>执行默认操作，Linux 对每种信号都规定了</p>
<p>默认行为，是下面的一种</p>
<ul>
<li>进程终止</li>
<li>进程终止并转储内存（core dump）</li>
<li>进程停止（挂起）直到被 SIGCONT 信号重启</li>
<li>进程忽略该信号</li>
</ul>
</li>
<li><p>忽略信号。当不希望接收到的信号对进程的执行产生影响，而让进程继续执行时，可以忽略该信号，即不对信号进程作任何处理，<code>SIGSTOP</code> 和 <code>SIGKILL</code> 无法忽略，也无法修改其默认行为</p>
</li>
<li><p>处理信号。定义信号处理程序，当信号发生时，执行相应的处理程序，使用 <code>sigaction</code> 可修改行为</p>
</li>
</ol>
<!-- TOC --><a name="-8"></a>
<h4 id="常见的陷阱、中断、异常、信号有哪些？"><a href="#常见的陷阱、中断、异常、信号有哪些？" class="headerlink" title="常见的陷阱、中断、异常、信号有哪些？"></a>常见的陷阱、中断、异常、信号有哪些？</h4><p>常见的陷阱（系统调用）：fork，exec，open，read，write 等</p>
<p>中断：中断包括 I&#x2F;O 设备发出的 I&#x2F;O 中断、各种定时器引起的时钟中断、调试程序中设置的断点等引起的调试中断等。</p>
<p>异常：除法（除零）异常、缺页异常等</p>
<p>信号：</p>
<p><img src="/./imgs/%E3%80%90%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E3%80%91%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/image-20240726085124985.png" alt="image-20240726085124985"></p>
<p><img src="/./imgs/%E3%80%90%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E3%80%91%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/image-20240726085151116.png" alt="image-20240726085151116"></p>
<!-- TOC --><a name="ctrl-cctrl-zkill-9-"></a>

<h4 id="Ctrl-C、Ctrl-Z、kill-、kill-9-的原理"><a href="#Ctrl-C、Ctrl-Z、kill-、kill-9-的原理" class="headerlink" title="Ctrl + C、Ctrl + Z、kill 、kill -9 的原理"></a><code>Ctrl + C</code>、<code>Ctrl + Z</code>、<code>kill</code> 、<code>kill -9</code> 的原理</h4><p>按下 Ctrl+C 发送 <code>SIGINT</code> (2)信号</p>
<p>按下 Ctrl+Z 发送 <code>SIGTSTP</code> (19)信号</p>
<p>kill 默认发送 <code>SIGTERM</code> (15)信号，可以在退出之前让程序执行清理操作、保存其状态或执行任何其他操作</p>
<p>kill -9 发送 <code>SIGKILL</code> (9)信号，程序会立即终止，没有机会保存其状态或释放资源。谨慎使用</p>
<h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><h4 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h4><p>进程是操作系统<strong>分配资源</strong>和<strong>调度</strong>的基本单位，进程会拥有内存空间的代码、数据，打开的文件，CPU 等资源</p>
<p>线程是操作系统进行<strong>调度</strong>的基本单位，线程除了 <strong>运行状态</strong> 是私有的，内存、打开文件等都是线程之间共享的</p>
<table>
<thead>
<tr>
<th></th>
<th>进程</th>
<th>线程</th>
</tr>
</thead>
<tbody><tr>
<td>资源</td>
<td>进程是一个<strong>拥有资源</strong>和<strong>执行任务</strong>的单元体。</td>
<td>线程是一个<strong>执行任务</strong>的单元体，<strong>不拥有资源</strong>，线程之间<strong>共享地址空间</strong></td>
</tr>
<tr>
<td>切换开销</td>
<td>开销很大</td>
<td>开销很小</td>
</tr>
<tr>
<td>通信</td>
<td>IPC</td>
<td>共享内存</td>
</tr>
<tr>
<td>健壮性</td>
<td>健壮，多个进程之间不会互相干扰</td>
<td>不健壮，一个线程出错会终止整个进程</td>
</tr>
</tbody></table>
<h4 id="线程，进程的上下文切换"><a href="#线程，进程的上下文切换" class="headerlink" title="线程，进程的上下文切换"></a>线程，进程的上下文切换</h4><p><strong>进程的上下文切换</strong>：在内核中，每个进程都有一个<strong>程序控制块 PCB</strong>来表示，其被保存在内存中，进程上下文切换的过程，就是将<strong>寄存器状态保存</strong>到 PCB 中，并找到新的  PCB，将其之前保存的内容加载到寄存器上，此外，还需要<strong>切换根页表目录</strong> ，以及<strong>刷新 TLB 缓存</strong> 。总之，进程的切换涉及：</p>
<ol>
<li>更新页表&#x2F;MMU；</li>
<li>刷新 TLB；</li>
<li>保存和加载新旧 PCB 中的寄存器状态；<ul>
<li>将关键寄存器的值（如程序计数器和标志寄存器）<strong>保存到 previous PCB</strong></li>
<li>将关键寄存器的值（如程序计数器和标志寄存器）<strong>从 next PCB 恢复</strong></li>
</ul>
</li>
</ol>
<p><strong>线程的上下文切换</strong>：由于线程之间<strong>共享地址空间</strong>，所以，线程的切换<strong>不涉及页表和TLB的更新</strong>，只需要切换线程的寄存器状态即可，即只包含上面的第二步。</p>
<h4 id="涉及内核线程的上下文切换有什么不同"><a href="#涉及内核线程的上下文切换有什么不同" class="headerlink" title="涉及内核线程的上下文切换有什么不同"></a>涉及内核线程的上下文切换有什么不同</h4><p>内核线程与其他进程不同的是，它并没有属于自己的地址空间所以在上下文切换时，内核线程会 <strong>“借用”<strong>上一个用户进程的地址空间 <code>next-&gt;active_mm = oldmm</code>，自己的 <code>mm = NULL</code> 标识自己为内核线程。此外，在借用地址空间后，</strong>并不需要刷新页表和 TLB</strong>，这样做的目的时为了加快上下文切换的速度。</p>
<p>寄存器和栈的切换和其他线程没什么不同。</p>
<p>上下文切换完成后，内核线程就在上一个用户进程的<strong>地址空间上半部</strong>（内核地址空间）运行。</p>
<p>具体实现上，如果下一个进程的 <code>mm == NULL</code> ，则</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (next-&gt;mm == <span class="literal">NULL</span>) &#123;				<span class="comment">/* 下一个是内核线程 */</span></span><br><span class="line">       oldmm = prev-&gt;active_mm;		</span><br><span class="line">	next-&gt;active_mm = oldmm;		<span class="comment">/* 借用的上一个地址空间 */</span></span><br><span class="line">	<span class="type">atomic_inc</span>(&amp;oldmm-&gt;mm_count);	<span class="comment">/* 提前增加引用计数 */</span></span><br><span class="line">	enter_lazy_tlb(oldmm, next);	<span class="comment">/* 不刷新 tlb */</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>如果上一个进程是内核线程，则</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!prev-&gt;mm) &#123;					<span class="comment">/* 上一个是内核线程 */</span></span><br><span class="line">	prev-&gt;active_mm = <span class="literal">NULL</span>;			</span><br><span class="line">	rq-&gt;prev_mm = oldmm;			<span class="comment">/* 在rq-&gt;prev_mm上保存了上一次使用的mm struct */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，我们还在内核线程的上下文运行，并不能释放地址空间，而是需要在下一个进程中释放，这就引出了下一个重要的问题：</p>
<h4 id="switch-to-函数为什么需要三个参数"><a href="#switch-to-函数为什么需要三个参数" class="headerlink" title="switch_to 函数为什么需要三个参数"></a>switch_to 函数为什么需要三个参数</h4><p><img src="/./imgs/%E3%80%90%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E3%80%91%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/image-20240808142127702.png" alt="image-20240808142127702"></p>
<p>一次 <code>switch_to</code> 函数的调用涉及<strong>三个进程</strong>，<code>A</code> 是被调度下去的进程，<code>B</code> 是在 <code>A</code> 之后调度上 CPU 的进程，<code>X</code> 是经过漫长的调度过程后，在 <code>A</code> 再次调度上 CPU 时的上一个进程！</p>
<p>上面说到，如果 <code>X</code> 是内核线程，这时就需要 <code>A</code> 为 <code>X</code> 做一些善后工作，如果 <code>switch_to</code> 只使用两个参数，那么 <code>A</code> 上下文中 <code>prev</code> 上一个进程永远都是 <code>B</code>，这显然不合理，所以，<code>switch_to</code> 需要第三的参数，用作 <code>A</code> 再次被调度时，告诉它上一个运行的进程是谁：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> switch_to(prev, next, last)                    	\</span></span><br><span class="line"><span class="meta">    do &#123;                                				\</span></span><br><span class="line"><span class="meta">        ((last) = __switch_to((prev), (next)));         \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br></pre></td></tr></table></figure>

<h3 id="进程与线程的通信方式"><a href="#进程与线程的通信方式" class="headerlink" title="进程与线程的通信方式"></a>进程与线程的通信方式</h3><table>
<thead>
<tr>
<th>方式</th>
<th>传输的信息量</th>
<th>使用场景</th>
<th>关键词</th>
</tr>
</thead>
<tbody><tr>
<td>信号</td>
<td>少量</td>
<td>任何</td>
<td>硬件来源 &#x2F; 软件来源 &#x2F; 信号队列 &#x2F; 中断返回 &#x2F; 系统调用返回</td>
</tr>
<tr>
<td>管道</td>
<td>大量</td>
<td>亲缘进程间</td>
<td>单向流动 &#x2F; 内核缓冲区 &#x2F; 循环队列 &#x2F; 没有格式的字节流 &#x2F; 操作系统负责同步</td>
</tr>
<tr>
<td>命名管道</td>
<td>大量</td>
<td>任何</td>
<td>磁盘文件 &#x2F; 访问权限 &#x2F; 无数据块 &#x2F; 内核缓冲区 &#x2F; 操作系统负责同步</td>
</tr>
<tr>
<td>信号量</td>
<td>N</td>
<td>任何</td>
<td>互斥同步 &#x2F; 原子性 &#x2F; P 减 V 增</td>
</tr>
<tr>
<td>共享内存</td>
<td>大量</td>
<td>多个进程</td>
<td>内存映射 &#x2F; 简单快速 &#x2F; 操作系统不保证同步</td>
</tr>
<tr>
<td>消息队列</td>
<td>比信号多，但有限制</td>
<td>任何</td>
<td>有格式 &#x2F; 按消息类型过滤 &#x2F; 操作系统负责同步</td>
</tr>
<tr>
<td>套接字</td>
<td>大量</td>
<td>不同主机的进程</td>
<td>读缓存区 &#x2F; 写缓冲区 &#x2F; 操作系统负责同步</td>
</tr>
</tbody></table>
<h4 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h4><p>信号就是操作系统<strong>预先定义</strong>的一些<strong>事件</strong>，进程可以对这些事件进行一些自定义的<strong>响应</strong>。</p>
<p><strong>内核与进程的通信</strong>：信号机制常用于<strong>内核与进程的通信</strong>，例如当进程访问非法内存时，收到 <code>SIGSEGV</code> 信号，想当于通知进程出现了段错误，默认情况下，进程终止并转储。</p>
<p><strong>进程之间的通信</strong>：进程可以通过 <code>kill</code> 系统调用向其他进程发送信号，函数原型为： <code>int kill(pid_t pid, int sig)</code>。</p>
<p>信号机制的原理：</p>
<ol>
<li>信号的发送<ul>
<li>使用 <code>kill</code> 系统调用后，陷入内核，内核会根据 <code>pid</code> 找到 <code>task_struct</code> </li>
<li>将信号放入目标进程的<strong>信号队列</strong> <code>pending</code> 中</li>
</ul>
</li>
<li>信号的接收<ul>
<li>像上面说的，每个进程都有一个队列，用来存放<strong>待决的信号</strong></li>
<li>在<strong>系统调用或中断返回前</strong>，内核会检查每个进程的 <code>pending</code> 列表</li>
<li>如果有待决的信号，则<strong>跳转到信号处理函数</strong>执行</li>
</ul>
</li>
<li>信号的处理<ul>
<li>忽略信号：当进程不希望被某信号打扰，可以忽略该信号，但 <code>SIGSTOP</code>、<code>SIGKILL</code> 无法忽略</li>
<li>处理信号：进程可以自定义信号处理函数，如使用 <code>signal</code> 或 <code>sigaction</code> 函数</li>
<li>默认处理：进程未定义信号处理函数时，使用默认的处理方式，一般是杀死或挂起进程</li>
</ul>
</li>
</ol>
<h4 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h4><p>匿名管道用于有<strong>亲缘关系</strong>的进程之间进行通信，通过 <code>pipe(int pipefd[2])</code> 系统调用创建<strong>读写文件描述符</strong>，随后使用 <code>fork</code> 或 <code>clone</code> 创建子进程，共享文件描述符，这样两个进程就能分别在其中一个文件描述符上读写了。</p>
<p><strong>实现</strong> ：匿名管道是借助 <code>VFS</code> 实现的，如下图，其<strong>申请了一个物理页</strong>、<strong>创建了 inode</strong> 和 <strong>file 对象</strong>；两个 file 对象的 f_op 就是对物理页的读取&#x2F;写入操作，对于该物理页内核使用<strong>环形缓冲区</strong>的方式进行管理。</p>
<p><strong>同步</strong>：内核使用<strong>互斥锁</strong>，保证父子进程对管道的互斥访问</p>
<p><img src="/./imgs/%E3%80%90%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E3%80%91%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/image-20240801164404729.png" alt="image-20240801164404729"></p>
<h4 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h4><p>一句话概述，命名管道除了会<strong>在物理磁盘上真正创建索引节点</strong>外，和匿名管道的其他方面类似</p>
<p>通过 <code>mknode()</code> 系统调用或者 <code>mkfifo()</code> 函数建立命名管道，该系统调用会在<strong>物理磁盘上真正创建一个索引节点</strong>，但是磁盘上并<strong>没有真正的文件</strong>数据块，也是通过<strong>内核缓冲区</strong>来实现数据传输。</p>
<p>一旦建立 <strong>FIFO文件</strong>，任何有访问权的进程都可以通过文件名将其打开和进行读写，而不局限于父子进程。</p>
<p>当不再被任何进程使用时，命名管道<strong>内核缓冲区</strong>被释放，但磁盘节点仍然存在。</p>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>信号量本质上是一个整数，代表某种资源的数量，对它的 P，V 操作都是<strong>原子</strong>的。</p>
<ul>
<li>V(S)：如果有其他进程因等待 S 而被阻塞，就让它恢复运行，否则 S 加 1</li>
<li>P(S)：如果 S 为 0，则阻塞进程，否则 S 减 1</li>
</ul>
<p>信号量在底层的实现是通过硬件提供的原子指令，如 <code>Test And Set</code>、<code>Compare And Swap</code> 等。</p>
<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>无论是 System V 、Posix、还是 mmap() 都提供了共享内存的机制，但从底层原理上讲，都是<strong>内核开辟一片内存区域，然后多个用户进程可以将这片区域映射到它们自己的地址空间中进行读写</strong>。用户空间要负责读写该区域的互斥和同步。</p>
<p><img src="/./imgs/%E3%80%90%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E3%80%91%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/image-20240802092625556.png" alt="image-20240802092625556"></p>
<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>消息队列使用<strong>内核维护的链表</strong>来实现，每个消息是由<strong>边界</strong>的，每个 MQ 通过<strong>消息队列描述符</strong>来区分（qid）。</p>
<p><img src="/./imgs/%E3%80%90%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E3%80%91%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/image-20240802092935206.png" alt="image-20240802092935206"></p>
<h4 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字 socket"></a>套接字 socket</h4><p>不同的计算机的进程之间通过 socket 通信，<em>也可用于同一台计算机的不同进程</em></p>
<p>操作系统提供创建 socket、发送、接收的系统调用，为每个 socket 设置发送缓冲区、接收缓冲区。</p>
<h4 id="各种-IPC-适用什么场景"><a href="#各种-IPC-适用什么场景" class="headerlink" title="各种 IPC 适用什么场景"></a>各种 IPC 适用什么场景</h4><table>
<thead>
<tr>
<th>方式</th>
<th align="left">类型</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>信号</td>
<td align="left"><strong>任意进程</strong>间的<strong>通知</strong>机制</td>
<td align="left">进程间的简单<strong>通知和控制</strong>，如内核终止、暂停进程</td>
</tr>
<tr>
<td>管道</td>
<td align="left"><strong>亲缘进程</strong>间的<strong>单向字节流</strong></td>
<td align="left">适合简单的<strong>父子进程通信</strong></td>
</tr>
<tr>
<td>命名管道</td>
<td align="left"><strong>任意进程</strong>间的<strong>双向字节流</strong></td>
<td align="left">需要<strong>长期存在</strong>且进程之间进行<strong>双向通信</strong>的场景</td>
</tr>
<tr>
<td>信号量</td>
<td align="left"><strong>任意进程</strong>间的<strong>计数器</strong></td>
<td align="left">用于多个进程之间的<strong>同步和互斥</strong>访问共享资源</td>
</tr>
<tr>
<td>共享内存</td>
<td align="left"><strong>任意进程</strong>间的共享<strong>内存区域</strong></td>
<td align="left">需要<strong>高效</strong>、<strong>频繁数据交换</strong>的场景</td>
</tr>
<tr>
<td>消息队列</td>
<td align="left"><strong>任意进程</strong>间的<strong>消息格式</strong>通信</td>
<td align="left">需要传递<strong>结构化</strong>数据和消息的场景</td>
</tr>
<tr>
<td>套接字</td>
<td align="left">支持在<strong>网络</strong>和本地进程间通信</td>
<td align="left">不同主机的进程进行<strong>网络通信</strong></td>
</tr>
</tbody></table>
<h4 id="要求进程崩溃重启后可以继续读写，该如何设计-IPC-方式"><a href="#要求进程崩溃重启后可以继续读写，该如何设计-IPC-方式" class="headerlink" title="要求进程崩溃重启后可以继续读写，该如何设计 IPC 方式"></a>要求进程崩溃重启后可以继续读写，该如何设计 IPC 方式</h4><p>这种情况下，可以使用下面两种 IPC 方式：</p>
<ol>
<li><strong>消息队列</strong>：消息队列中的消息在进程崩溃后会<strong>继续存在</strong>，直到被接收。</li>
<li><strong>mmap 共享文件映射</strong> ：当进程崩溃后，如果文件还在磁盘上且没有被删除，其他进程可以重新映射相同的文件，继续读取或写入数据。</li>
</ol>
<p>其他的方式无法实现继续读写的要求，比如：</p>
<ul>
<li>信号：进程崩溃或终止后，其相关的信号状态也随之丧失(task_struct 都没了，pending也没了)</li>
<li>管道：无论是匿名还是命名管道，均是通过创建内存来实现的，在进程崩溃后，相关内存会<strong>被系统回收</strong></li>
<li>共享内存：和<strong>命名管道</strong>类似，虽然其对象本身(FIFO 文件 )并未被回收，但相关内存会<strong>被系统回收</strong></li>
<li>mmap共享匿名映射：共享匿名映射的内存也会被回收</li>
<li>socket：对于 TCP 来说，连接会断开；对于 UDP 来说，数据会丢失。</li>
</ul>
<h3 id="并发与竞态"><a href="#并发与竞态" class="headerlink" title="并发与竞态"></a>并发与竞态</h3><h4 id="什么是线程安全，举个不安全的例子"><a href="#什么是线程安全，举个不安全的例子" class="headerlink" title="什么是线程安全，举个不安全的例子"></a>什么是线程安全，举个不安全的例子</h4><p>线程安全就是指，在多线程并发的场景下，多个线程对于共享数据的访问不能造成<strong>竞态或数据不一致</strong>。换句话说，对于共享数据的并发读写，应该和多个线程串行读写的结果一致。</p>
<p>例子：两个线程同时对一个共享整数做 <code>++</code> 操作，各加 50 次，由于竞态的存在，结果可能会导致共享整数<strong>被加次数小于 100 次</strong></p>
<p>原因：这是因为 <code>++</code> 操作并不是原子操作而导致的，在底层 <code>++</code> 操作可能被分解为 <code>读、该、写回</code> 等多个指令，两个线程的这些指令交叉执行就会导致竞态，所以需要合适的<strong>同步方法</strong>对临界区进行保护</p>
<h4 id="线程同步的方法"><a href="#线程同步的方法" class="headerlink" title="线程同步的方法"></a>线程同步的方法</h4><ul>
<li>互斥锁 <code>pthrad_mutex</code>：互斥访问，会<strong>阻塞</strong>等待锁的线程，释放锁时<strong>唤醒</strong>线程</li>
<li>条件变量 <code>pthread_cond</code>：可以使用一个<strong>等待队列</strong>、一个<strong>变量</strong> 以及保护变量的<strong>互斥锁</strong>实现</li>
<li>读写锁 <code>pthread_rwlock</code>：使用<strong>两个等待队列</strong>，一个用于等待读锁的线程，另一个用于等待写锁的线程</li>
<li>自选锁 <code>pthread_spin</code>：自旋等待</li>
<li>信号量 <code>sem</code> ：会<strong>阻塞</strong>等待锁的线程，释放锁时<strong>唤醒</strong>线程</li>
</ul>
<h4 id="何时使用多进程、又何时使用多线程"><a href="#何时使用多进程、又何时使用多线程" class="headerlink" title="何时使用多进程、又何时使用多线程"></a>何时使用多进程、又何时使用多线程</h4><p>多进程的优势：</p>
<ul>
<li>各个进程有各自的地址空间，带来了更好的<strong>隔离性</strong>；</li>
<li>同样的，各个进程之间的运行互不干扰，带来了更好的<strong>稳定性</strong>；</li>
</ul>
<p>当对<strong>隔离性和稳定性</strong>要求有要求时，应该使用多进程，比如 数据库服务器，可以保证一个连接的错误不影响其他连接。</p>
<p>多线程的优势：</p>
<ul>
<li>各个线程共享地址空间，带来了<strong>高效的数据共享</strong>，避免数据多次拷贝</li>
<li>由于上下文切换时无需切换地址空间，所以多线程<strong>创建和销毁开销更小</strong></li>
</ul>
<p>这种特性表示着多线程更适合<strong>高并发</strong>和<strong>IO密集型</strong>场景，例如需要处理大量的并发请求和高吞吐量的 Web 服务器。</p>
<h4 id="多线程下的-error-会有问题吗"><a href="#多线程下的-error-会有问题吗" class="headerlink" title="多线程下的 error 会有问题吗"></a>多线程下的 error 会有问题吗</h4><p>在 Linux 下，<code>errno</code> 是一个<strong>全局变量</strong>，用于保存<strong>系统调用或库函数</strong>出错时的错误代码。</p>
<ul>
<li>每个线程都拥有独立的 <code>errno</code> 副本</li>
<li>系统调用和库函数，设置 <code>errno</code> 时也是设置了每个线程的副本</li>
</ul>
<p>这样的设计，保证了 <code>errno</code> 在多线程的环境下仍然是安全的</p>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="两台主机间的-TCP-通信过程"><a href="#两台主机间的-TCP-通信过程" class="headerlink" title="两台主机间的 TCP 通信过程"></a>两台主机间的 TCP 通信过程</h3><p>这里以建立连接时的 SYN 报文为例，看一下不同局域网内的主机通信时具体过程，以及会涉及哪些协议</p>
<ol>
<li>【主机】【应用层】通过 DNS 协议将域名解析为 IP 地址；</li>
<li>【主机】【传输层】封装 TCP 报文，建立连接使用 SYN 标志位，并选择一个序列号 seq；</li>
<li>【主机】【网络层】封装 IP 数据包，源 IP 地址为本机 IP，目的 IP 地址为 域名 IP；</li>
<li>【主机】【网络层】查询路由表，根据 <strong>目的IP</strong> 寻找 <strong>下一跳IP</strong>；</li>
<li>【主机】【数据链路层】封装以太网帧，源 MAC 为本机 MAC，目的 MAC 通过<strong>下一跳IP</strong> 和 ARP 表获得；</li>
<li>【主机】【物理层】发送以太网帧，网卡会将以太网帧以比特流的形式发送出去；</li>
<li>【局域网】该帧会被局域网内的其他设备看到，根据 目的MAC 获取或丢弃该帧；</li>
<li>【网关&#x2F;路由器】【网络层】根据 目的MAC 该帧最终会被局域网网关捕获，网关重复 4~7 步，发送带有新的 源MAC 和 新的目的 MAC 的以太网帧；</li>
<li>【互联网】中间经过若干个下一跳主机，最终 IP 数据包发送到域名所在的局域网的网关，每一跳的过程中，两个 MAC地址 是不断变化的，两个 IP地址 从未改变。</li>
<li>【网关&#x2F;路由器】【网络层】目的局域网的网关，通过路由表发现，目的主机和自己在同一局域网；</li>
</ol>
<blockquote>
<p>当 <code>Gateway</code> 为 0.0.0.0 时，表示目的机器和当前主机位于同一个局域网内，它们互相连接，任何数据包都不需要路由，可以直接通过 MAC 地址发送到目的机器上。</p>
</blockquote>
<ol start="11">
<li>【网关&#x2F;路由器】【数据链路层】根据 ARP 表，查找目的 IP 的 MAC 地址，构造以太网帧；</li>
<li>【局域网】该帧会被局域网内的其他设备看到，根据 目的MAC 获取或丢弃该帧；</li>
<li>【目的主机】【数据链路层】根据 目的MAC，上述以太网帧会被目的组机接收；</li>
<li>【目的主机】【网络层】去掉 以太网头部，目的主机获取到了 IP 数据报；</li>
<li>【目的主机】【传输层】去掉 IP 头部，目的主机获取到了 TCP 报文；</li>
<li>【目的主机】【传输层】目的主机识别到 SYN 报文，会类似 2~15 步那样，发送 ACK 报文…</li>
</ol>
<h3 id="输入网址到出现网页的过程"><a href="#输入网址到出现网页的过程" class="headerlink" title="输入网址到出现网页的过程"></a>输入网址到出现网页的过程</h3><p>这个问题和上面的比较类似，但是，会涉及到浏览器以及 http协议的相关知识，这里仅补充这些。</p>
<ol>
<li>【主进程】用户输入 URL，回车；</li>
<li>【主进程】此时主线程会创建一个 <strong>网络连接线程</strong>；</li>
<li>【网络连接线程】网络连接线程会像上面描述的那样，进行 DNS 解析，TCP 三次握手，SSL 四次握手，从而建立了 http 连接。</li>
<li>【服务器】服务器收到第一条 http 报文后(<strong>read</strong>)，会解析请求，并返回请求内容(<strong>write</strong>)；</li>
<li>【浏览器】浏览器收到请求内容后，将内容交给渲染进程；</li>
<li>【浏览器】渲染进程，会解析返回内容，并绘制页面；</li>
<li>【浏览器】如果遇到 JS&#x2F;CSS&#x2F;图片等静态资源，会重复 2~6 步骤；</li>
</ol>
<p><img src="/./imgs/%E3%80%90%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E3%80%91%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/image-20240801084207363.png" alt="image-20240801084207363"></p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><h4 id="TCP-三次握手的过程"><a href="#TCP-三次握手的过程" class="headerlink" title="TCP 三次握手的过程"></a>TCP 三次握手的过程</h4><ol>
<li><p>【<strong>同步报文</strong>】客户端发送 SYN 报文，选择一个序列号 seq &#x3D; M</p>
</li>
<li><p>【<strong>同步确认报文</strong>】服务器发送 SYN ACK 报文，选择一个序列号 seq &#x3D; N，确认号 ack &#x3D; M + 1</p>
</li>
<li><p>【<strong>确认报文</strong>】客户端发送 ACK 报文，序列号 seq &#x3D; M + 1，确认后 ack &#x3D; N + 1</p>
<p><img src="/./imgs/%E3%80%90%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E3%80%91%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/image-20240801112249259.png" alt="image-20240801112249259"></p>
</li>
</ol>
<h4 id="TCP-四次挥手的过程"><a href="#TCP-四次挥手的过程" class="headerlink" title="TCP 四次挥手的过程"></a>TCP 四次挥手的过程</h4><ol>
<li>【<strong>连接释放报文</strong>】客户端发送 FIN 报文，seq &#x3D; y</li>
<li>【<strong>确认报文</strong>】服务器端发送 ACK 报文，seq &#x3D; z，ack &#x3D; y + 1，并携带未发完的数据</li>
<li>【<strong>连接释放报文</strong>】服务器端发送 FIN ACK 报文， seq &#x3D; p, ack &#x3D; y + 1</li>
<li>【<strong>确认报文</strong>】客户端发送 ACK 报文 , seq &#x3D; y + 1, ack &#x3D; p + 1</li>
</ol>
<p><img src="/./imgs/%E3%80%90%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E3%80%91%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/image-20240801113032935.png" alt="image-20240801113032935"></p>
<h4 id="TCP-如何进行流量控制"><a href="#TCP-如何进行流量控制" class="headerlink" title="TCP 如何进行流量控制"></a>TCP 如何进行流量控制</h4><p>什么是流量控制？在传输过程中，如果发送方发送的速度过快，接收方来不及处理，就会造成大量丢包，所以，使用滑动窗口机制，对<strong>发送方的发送速率进行限制</strong>。</p>
<p>TCP 使用滑动窗口进行流量控制，在发送方和接收方各有一个缓冲区</p>
<p>发送方的缓冲区包括：</p>
<ul>
<li><strong>已确认指针</strong>：指向接收方已确认的最后一个字节</li>
<li><strong>已发送指针</strong>：指向已发送数据的最后一个字节</li>
<li><strong>应用写入指针</strong>：指向应用程序写入缓冲区的最后一个字节</li>
</ul>
<p>接收方的缓冲区包括：</p>
<ul>
<li><strong>未确认指针</strong>：指向第一个未确认字节</li>
<li><strong>已接收指针</strong>：指向最新接收的最后一个字节</li>
<li><strong>应用读取指针</strong>：指向应用程序读取到的最后一个字节</li>
</ul>
<p><img src="/./imgs/%E3%80%90%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E3%80%91%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/image-20240801103914121.png" alt="image-20240801103914121"></p>
<p>那么，接收方此时会在 TCP 头部 <code>window</code> 字段表明自己当前可容纳的数据大小：</p>
<p><code>请求窗口大小</code> &#x3D; <code>接收方缓冲区大小</code> - <code>已接收指针</code> - 1</p>
<p>发送方读取到该窗口大小后，会根据这个窗口来控制发送数据的大小，以保证接收方可以处理</p>
<h4 id="TCP-如何进行拥塞控制"><a href="#TCP-如何进行拥塞控制" class="headerlink" title="TCP 如何进行拥塞控制"></a>TCP 如何进行拥塞控制</h4><p>什么是拥塞控制？拥塞控制旨在是发送端的发送速度适应网络环境，解决网络拥塞问题。</p>
<p>TCP 也是使用滑动窗口机制来实现拥塞控制的，发送端会维护一个 <code>cwnd</code> 拥塞窗口，并使用 <strong>慢启动、拥塞避免、超时重传、快速重传&#x2F;快速恢复</strong> 等机制实现拥塞控制。</p>
<ol>
<li><p><strong>慢启动</strong>：指数增加，探测网络容量</p>
<ul>
<li>连接建立时，拥塞窗口 <code>cwnd = 1</code> 代表可以发送一个 MSS 大小的数据</li>
<li>每收到一个 ACK 报文，<code>cwnd++</code> 加一</li>
<li>每经过一个 RTT 时间，<code>cwnd *= 2</code> 翻倍</li>
</ul>
<p>当 <code>cwnd &gt;= ssthresh</code> 大于等于 慢启动阈值 时，进入拥塞避免</p>
</li>
<li><p><strong>拥塞避免</strong>：加法增加，探测网络容量</p>
<ul>
<li>每收到一个 ACK 包，<code>cwnd = cwnd + 1/cwnd</code></li>
<li>每经过一个 RTT，<code>cwnd = cwnd + 1</code>（加法增大）</li>
</ul>
</li>
<li><p><strong>超时重传</strong>：计时器超时！说明<strong>网络拥塞</strong></p>
<p>当等待队列中出现 <strong>计时器超时</strong> 时，说明网络拥塞，重新慢启动</p>
<ul>
<li><code>ssthresh = cwnd / 2</code> ，慢启动阈值设为拥塞窗口的一半</li>
<li><code>cwnd = 1</code>，重新开始<strong>慢启动</strong></li>
</ul>
</li>
<li><p><strong>快重传&#x2F;快恢复</strong>：收到多个重复 ACK 时，说明<strong>轻微丢包，轻微拥塞</strong> </p>
<p>接收端收到<strong>乱序包</strong>时，会发送 <strong>重复 ACK</strong> 通知发送端。当发送端收到 3 个 重复 ACK 时，就<strong>立刻开始重传</strong>，而不必继续等待到计时器超时。</p>
<ul>
<li><code>ssthresh = cwnd / 2</code> ，慢启动阈值设为拥塞窗口的一半</li>
<li><code>cwnd = ssthresh</code>，重新开始<strong>拥塞避免</strong>过程</li>
</ul>
</li>
</ol>
<p>​		为什么快速重传不需要像超时重传那样，将 <code>cwnd</code> 重置为 1 重新开始慢启动呢？因为它认为如果网络出现拥塞的话，是不会收到好几个重复的 ACK 的，所以现在网络<strong>可能没有出现拥塞</strong>。</p>
<p><img src="/./imgs/%E3%80%90%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E3%80%91%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/image-20240801114559664.png" alt="image-20240801114559664"></p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><h4 id="如何使用-UDP-实现可靠传输"><a href="#如何使用-UDP-实现可靠传输" class="headerlink" title="如何使用 UDP 实现可靠传输"></a>如何使用 UDP 实现可靠传输</h4><p>如果想要实现可靠传输，那么就需要在应用层设计合理的协议，至少要满足<strong>序号、确认、重传、流量控制、拥塞控制</strong> </p>
<ol>
<li><p><strong>序号</strong></p>
<ul>
<li>序号机制可以保证数据包的<strong>先后顺序</strong>，供接收方来进行数据重排；</li>
<li>序号机制是实现确认和重传的基础；有了序号才能匹配确认报文，进而对超时未确认报文的重传；</li>
</ul>
</li>
<li><p><strong>确认</strong></p>
<ul>
<li>接收方需要对收到的报文进行确认</li>
</ul>
</li>
</ol>
<blockquote>
<p>可以像 TCP 那样确认号代表之前报文全部收到，也可以牺牲一些带宽进行选择性确认。</p>
</blockquote>
<ol start="3">
<li><p><strong>重传</strong> </p>
<ul>
<li>发送方发送完一个报文后，将其放入待确认队列，并开启计时器，如果计时器超时，则重传该报文</li>
</ul>
</li>
<li><p><strong>流量控制</strong> </p>
<ul>
<li>可以像 TCP 那样，使用滑动窗口机制，发送方允许发送的数据受到<strong>发送方的发送窗口大小</strong> ，<strong>接收方的接收窗口大小</strong> ，以及<strong>拥塞窗口大小</strong> 确定。</li>
</ul>
</li>
<li><p><strong>拥塞控制</strong> </p>
<ul>
<li>也可以像 TCP 那样，使用<strong>慢开始、拥塞避免、快重传和快恢复</strong>等处理方式进行拥塞控制</li>
</ul>
</li>
</ol>
<h3 id="TCP-v-s-UDP"><a href="#TCP-v-s-UDP" class="headerlink" title="TCP v.s.UDP"></a>TCP v.s.UDP</h3><h4 id="TCP-和-DUP-的区别"><a href="#TCP-和-DUP-的区别" class="headerlink" title="TCP 和 DUP 的区别"></a>TCP 和 DUP 的区别</h4><p>首先最重要的就是二者的 3 个特征点：</p>
<p>TCP 提供<strong>面向连接</strong> 、<strong>可靠的</strong> 的 <strong>双向字节流</strong>传输</p>
<p>UDP 提供<strong>无连接、不可靠</strong> 的 <strong>数据报</strong>传输</p>
<table>
<thead>
<tr>
<th></th>
<th><em>TCP</em></th>
<th><em>UDP</em></th>
</tr>
</thead>
<tbody><tr>
<td><strong>连接性</strong></td>
<td><strong>面向连接</strong></td>
<td><strong>无连接</strong></td>
</tr>
<tr>
<td><strong>可靠性</strong></td>
<td><strong>可靠</strong></td>
<td><strong>不可靠</strong></td>
</tr>
<tr>
<td><strong>传输方式</strong></td>
<td><strong>面向字节流</strong></td>
<td><strong>面向数据报（保留报文的边界）</strong></td>
</tr>
<tr>
<td>传输速度</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>双工性</td>
<td>全双工</td>
<td>一对一、一对多、多对一、多对多</td>
</tr>
<tr>
<td>流量控制 &#x2F; 拥塞控制</td>
<td>有</td>
<td>无</td>
</tr>
<tr>
<td>应用场景</td>
<td>对效率要求相对低，但是对准确性要求高的场景；或是要求有连接的场景。如文件传输、发送邮件等</td>
<td>对效率要求相对高，对准确性要求相对低的场景。如即时通信、直播等</td>
</tr>
<tr>
<td>应用层协议</td>
<td>SMTP（电子邮件）、TELNET（远程登录控制）、HTTP、FTP</td>
<td>DNS、TFTP（文件传输）、DHCP（动态主机配置）…</td>
</tr>
</tbody></table>
<h4 id="UDP-为什么比-TCP-快"><a href="#UDP-为什么比-TCP-快" class="headerlink" title="UDP 为什么比 TCP 快"></a>UDP 为什么比 TCP 快</h4><ol>
<li><strong>头部大小</strong>：UDP 报头（8 字节）比 TCP 报头（最小 20 字节）更小，所以传输速度更快</li>
<li><strong>连接</strong>：TCP 面向连接需要进行 三次握手、四次挥手 等动作，而 UDP 则不需要</li>
<li><strong>可靠性保证</strong>：TCP 为了保证可靠性，需要确认机制、超时重传、乱序重排、拥塞，流量控制等机制，大大增加了网络传输延时。</li>
</ol>
<h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><h4 id="socket-中各函数，对应客户端和服务器哪些行为"><a href="#socket-中各函数，对应客户端和服务器哪些行为" class="headerlink" title="socket 中各函数，对应客户端和服务器哪些行为"></a>socket 中各函数，对应客户端和服务器哪些行为</h4><ol start="0">
<li><p>【服务器】使用 <code>socket</code> 函数创建一个 socket</p>
</li>
<li><p>【服务器】使用 <code>bind</code> 为 socket 设置 IP 地址和 端口</p>
</li>
<li><p>【服务器】使用 <code>listen</code> 将 socket 设为 LISTEN 状态，内核开始监听 IP &amp; 端口，这个过程，内核会完成三次握手的过程（<strong>SYN Queue</strong>），建立 TCP 连接，将连接放入 <strong>Accept Queue</strong>，供 <code>accept</code> 获取</p>
</li>
<li><p>【服务器】使用 <code>accept</code> 完成连接的建立，如果  <strong>Accept Queue</strong> 为空，该函数会阻塞，否则取出一个连接，并为其创建一个新的 socket，并返回。</p>
</li>
<li><p>【服务器】一般情况下，主线程会创建新的线程，并使用 accept 返回的新 socket 进行读写</p>
</li>
<li><p>【客户端】使用 <code>socket</code> 函数创建一个 socket</p>
</li>
<li><p>【客户端】使用 <code>connect</code> 函数完成 三次握手过程，一般情况下，该函数会阻塞，直到连接创建成功</p>
</li>
<li><p>【客户端】使用 <code>read</code> &#x2F; <code>write</code> 等函数进行读写</p>
</li>
<li><p>【客户端】使用 <code>close</code> 函数关闭 socket，引用计数减一 或 内核完成四次挥手</p>
</li>
</ol>
<h4 id="socket-通信时，进程崩溃会发生什么"><a href="#socket-通信时，进程崩溃会发生什么" class="headerlink" title="socket 通信时，进程崩溃会发生什么"></a>socket 通信时，进程崩溃会发生什么</h4><p><strong>对于 TCP 连接：</strong></p>
<p>【本地崩溃】：本地进程崩溃，操作系统会回收进程 socket 资源，通常会发送连接重置报文到对端</p>
<p>【对端崩溃】：</p>
<ul>
<li>如果收到 RTS 连接重置报文，那可以进行相应处理，比如关闭 socket；</li>
<li>如果没收到，那么会在报文达到<strong>最大重传次数</strong>时，关闭连接</li>
</ul>
<p><strong>对于 UDP 连接：</strong></p>
<p>【本地崩溃】：本地进程崩溃，操作系统会回收进程 socket 资源</p>
<p>【对端崩溃】：UDP 是无连接的，因此对端进程崩溃<strong>不会直接影响</strong>到本地进程，只会发现数据未到达</p>
<h4 id="socket-读写如何区分缓冲区空-满还是连接已断开"><a href="#socket-读写如何区分缓冲区空-满还是连接已断开" class="headerlink" title="socket 读写如何区分缓冲区空&#x2F;满还是连接已断开"></a>socket 读写如何区分缓冲区空&#x2F;满还是连接已断开</h4><ol>
<li>read 读取时</li>
</ol>
<ul>
<li><strong>连接断开</strong>：</li>
</ul>
<p>   ​		返回 <code>0</code> 表示正常连接关闭；</p>
<p>   ​		返回 <code>-1</code> ，<code>errno</code> 设为 <code>ECONNRESET</code>，表示异常关闭；</p>
<ul>
<li><p><strong>缓冲区空</strong>： </p>
<p>返回 <code>-1</code>，<code>errno</code> 设为 <code>EAGAIN</code>，表示缓冲区空；</p>
</li>
</ul>
<ol start="2">
<li><p>write 写入时</p>
<ul>
<li><p><strong>连接断开</strong>：</p>
<p> 返回 <code>-1</code> ，<code>errno</code> 设为 <code>EPIPE</code>，表示连接关闭；	</p>
</li>
<li><p><strong>缓冲区空</strong>：</p>
<p> 返回 <code>-1</code>， <code>errno</code> 设为 <code>EAGAIN</code>，表示缓冲区满；</p>
</li>
</ul>
</li>
</ol>
<p>返回 <code>-1</code>，<code>errno</code> 设为 <code>EAGAIN</code>，表示缓冲区空；</p>
<h4 id="epoll-比-select-高效的原因"><a href="#epoll-比-select-高效的原因" class="headerlink" title="epoll 比 select 高效的原因"></a>epoll 比 select 高效的原因</h4><ol>
<li>select 是通过遍历检查 文件描述符数组，来查看每个 <code>fd</code> 状态的，这种主动查询的方式效率低下；而epoll 是通过<strong>向驱动程序中的等待队列注册回调函数</strong>实现让每个 <code>fd</code> 自动回调通知的。具体来说，</li>
<li>其次，每次调用 select 都需要将文件描述符数组从用户层拷贝到内核，而 epoll 在使用 epoll_ctl 将文件描述符添加到内核后，每次调用 epoll_wait 无需再次拷贝</li>
</ol>
<h4 id="使用-LT-水平触发，监听多个写事件，如何保证写就绪后-epoll-wait-下一次不返回"><a href="#使用-LT-水平触发，监听多个写事件，如何保证写就绪后-epoll-wait-下一次不返回" class="headerlink" title="使用 LT 水平触发，监听多个写事件，如何保证写就绪后 epoll_wait 下一次不返回"></a>使用 LT 水平触发，监听多个写事件，如何保证写就绪后 epoll_wait 下一次不返回</h4><p>从 epoll_wait 的实现上来看，将就绪 <code>fd</code> 返回用户空间时，epoll 会将就绪链表中的 epitem 拷贝到一个<strong>临时链表</strong>，并将 LT 触发的 epitem 再放回原就绪链表中，这样就实现了多次返回。</p>
<p>而在将每个 <code>fd</code> 返回用户空间之前，epoll 在次调用驱动的 poll 函数，检查就绪状态（这里调用 poll 函数传入的 poll_table 为 NULL，不会加入等待队列），只有就绪状态仍符合的 <code>fd</code> 才会被返回用户空间。</p>
<p>通过上面的分析，这个问题就容易解答了，只需要在写就绪后，循环写入缓冲区，直到缓冲区满即可。这样下次调用 epoll_wait 时，会再次调用驱动 poll 函数，发现就绪状态不满足了，就不会返回。</p>
<p>如果用户程序没有那么多数据要写，无法填满缓冲区，那么就需要将 <code>fd</code> 从 epoll 监听的红黑树中移除，待下次有数据要写入时再放入 epoll。</p>
<h4 id="epoll-为什么使用红黑树做数据结构"><a href="#epoll-为什么使用红黑树做数据结构" class="headerlink" title="epoll 为什么使用红黑树做数据结构"></a>epoll 为什么使用红黑树做数据结构</h4><p>在使用 epoll_ctl 函数时，会涉及 <code>fd</code> 的 查找、插入、删除操作，而红黑树是一颗<strong>较平衡的二叉查找树</strong>，其插入、查找、删除操作在所有数据结构中最为优秀，平均时间复杂度均为 <code>O(logn)</code> ，所以为了实现更快的插入、查找、删除速度，epoll 使用了红黑树作为数据结构。</p>
<h4 id="描述使用-epoll-实现服务端调用-api-的流程"><a href="#描述使用-epoll-实现服务端调用-api-的流程" class="headerlink" title="描述使用 epoll 实现服务端调用 api 的流程"></a>描述使用 epoll 实现服务端调用 api 的流程</h4><ol>
<li><p>使用 <code>socket</code>，<code>bind</code>，<code>listen</code> 创建、绑定并监听一个套接字 <code>sfd</code>；</p>
</li>
<li><p><code>epoll_create</code> 创建 epoll 对象；</p>
</li>
<li><p><code>epoll_ctl</code> 将刚刚创建的套接字加入到 epoll 对象的监控列表中；</p>
</li>
<li><p>进入事件循环：</p>
<ol>
<li><p>使用 <code>epoll_wait</code> 查看套接字状态，对于返回的 n 个事件，循环检查下面中情况；</p>
<ul>
<li><p><code>events[i].data.fd == sfd</code> 代表 1~N 个新连接的建立，需要循环 <code>accept</code> 这些连接，并将新创建的 <code>fd</code> 添加到 epoll 的监控列表；</p>
</li>
<li><p><code>events[i].events &amp; EPOLLERR</code> 代表出现错误，需要 <code>close</code> 相应的 <code>fd</code>，这会<strong>自动</strong>从 epoll 移除；</p>
</li>
<li><p>最后一种代表有数据可读&#x2F;可写，这时需要使用 <code>read</code> &#x2F; <code>write</code> 处理数据；</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>伪代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">sfd = socket();</span><br><span class="line">bind(sfd, addr, addrlen);</span><br><span class="line">listen(sfd);</span><br><span class="line"></span><br><span class="line">ep = epoll_create();</span><br><span class="line"></span><br><span class="line">epoll_event.data.fd = sfd;</span><br><span class="line">epoll_event.events = EPOLLIN | EPOLLET;</span><br><span class="line">epoll_ctl(ep, EPOLL_CTL_ADD, sfd, epoll_event);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Event Loop */</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    n = epoll_wait(ep, events, MAXEVENTS, timeout);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        fd = events.data.fd;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (events[i].events &amp; EPOLLERR) &#123;</span><br><span class="line">            close(fd);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fd == sfd) &#123;</span><br><span class="line">            <span class="keyword">while</span> ((infd = accept(sfd, &amp;in_addr, &amp;in_len)) &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                	event.data.fd = infd;</span><br><span class="line">                    event.events = EPOLLIN | EPOLLET;</span><br><span class="line">                    s = epoll_ctl(ep, EPOLL_CTL_ADD, infd, &amp;event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(read(fd, buf, <span class="keyword">sizeof</span> buf)) &#123;</span><br><span class="line">                handle_data();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sendfile-系统调用解决的问题"><a href="#sendfile-系统调用解决的问题" class="headerlink" title="sendfile 系统调用解决的问题"></a>sendfile 系统调用解决的问题</h4><p>sendfile 是 <strong>零拷贝</strong> 技术的一种具体实现。</p>
<p>以 web 服务器为例，使用传统的 IO 方式，需要使用 <code>read</code> ，<code>write</code> 系统调用：</p>
<ol>
<li>将数据从磁盘拷贝到 内核缓冲区，可以使用 DMA 方式；</li>
<li>将数据从 内核缓冲区 拷贝到 用户缓冲区，这需要 CPU 处理；</li>
<li>将数据从 用户缓冲区 拷贝到 socket 缓冲区，这也需要 CPU 处理；</li>
<li>最后使用 使用 DMA 将数据从网卡发送出去；</li>
</ol>
<p>这种使用传统 IO 的方式，涉及 2 次数据拷贝，以及 4 次上下文切换，影响系统效率。而且，由于用户层无需对数据进行修改，所以向用户层拷贝数据是无意义的。</p>
<p><strong>sendfile ** 系统调用的提出就是为了解决</strong>数据的无效拷贝**问题，对于上面的场景使用 sendfile 系统调用：</p>
<ol>
<li>将数据从磁盘拷贝到 内核缓冲区，可以使用 DMA 方式；</li>
<li>将数据从 内核缓冲区 之间拷贝到 socket 缓冲区，这需要 CPU 处理；</li>
<li>使用 DMA 将数据从网卡发送出去；</li>
</ol>
<p>可见，使用 sendfile 系统调用仅涉及 1 次数据拷贝，1 次上下文切换，效率很高。</p>
<p>更进一步，如果网卡支持 SG-DMA，那么数据可以之间从 内核缓冲区 通过 SG-DMA 技术发送到网卡，全程无需 CPU 进行数据拷贝！</p>
<h3 id="程序运行"><a href="#程序运行" class="headerlink" title="程序运行"></a>程序运行</h3><h4 id="gcc-编译过程"><a href="#gcc-编译过程" class="headerlink" title="gcc 编译过程"></a>gcc 编译过程</h4><ul>
<li>预处理：包括<strong>头文件展开</strong>、<strong>条件编译</strong>、<strong>宏替换</strong>、<strong>删除注释</strong> 等工作</li>
<li>编译阶段：包括词法分析、语法分析、语义分析等，完成<strong>c语言到汇编语言</strong>的转换</li>
<li>汇编阶段：将<strong>汇编代码转化为机器码</strong>，生成目标文件</li>
<li>链接阶段：包括符号解析和重定位等，将多个目标文件合并成一个可执行文件或库文件</li>
</ul>
<h4 id="ELF-文件格式"><a href="#ELF-文件格式" class="headerlink" title="ELF 文件格式"></a>ELF 文件格式</h4><ol>
<li>ELF 头部：记录了 ELF 文件的<strong>元信息</strong>，如 ELF 文件类型（可执行、目标、共享库）、入口地址等</li>
<li>程序头表：记录了 ELF 文件的<strong>段信息</strong>，段信息包括<strong>段类型与大小</strong>、<strong>段在 ELF 文件中的偏移</strong>、<strong>段被加载到的内存地址</strong>等，这些信息告<strong>定义了文件在内存中的布局</strong></li>
<li>节头表：记录了 ELF 文件的<strong>节信息</strong>，包括各个节的<strong>名称、类型、偏移、大小</strong>等</li>
<li>节：记录了 ELF 文件的<strong>代码和数据</strong>，如 <code>.text</code>、<code>.data</code>、<code>.bss</code>、<code>.rodata</code> 等节；还记录了<strong>符号和重定位信息</strong>，如  <code>.symtab</code> 符号表节、<code>.rel.text</code> 重定位表节</li>
</ol>
<h4 id="静态链接的过程"><a href="#静态链接的过程" class="headerlink" title="静态链接的过程"></a>静态链接的过程</h4><ol>
<li>收集输入文件：包含<strong>目标文件</strong>和<strong>静态库文件</strong>，这些文件由<code>.text</code>、<code>.data</code>、 <code>.symtab</code> 、<code>.rel.text</code>  等节构成</li>
<li>符号解析：根据各个目标文件的<strong>符号表</strong>，生成<strong>全局符号表</strong>(符号名称、类型、位置、作用域等)，这个过程会检查未定义和重复定义错误</li>
<li>重定位：目标文件的<strong>重定位</strong>表记录了每个<strong>外部定义的符号</strong>，链接器会扫描每个文件的<strong>重定位表</strong>中的条目，从<strong>全局符号表</strong>中确认符号的最终地址，并修正</li>
<li>最后，生成<strong>程序头表</strong>、<strong>设置入口地址</strong>、<strong>生成可执行文件</strong></li>
</ol>
<h4 id="动态链接的过程"><a href="#动态链接的过程" class="headerlink" title="动态链接的过程"></a>动态链接的过程</h4><ol>
<li><p>输入文件：包含<strong>目标文件</strong> 和<strong>动态库文件</strong></p>
</li>
<li><p>ld 生成动态链接信息：生成<strong>动态符号表</strong>、<strong>动态重定位表</strong>、<strong>过程链接表（PLT）</strong>、<strong>全局偏移表（GOT）</strong> 等节</p>
</li>
<li><p>加载到内存：加载器将 <code>.text</code> 、<code>.data</code> 数据代码加载到内存，并根据 <code>PT_INTERP</code> 段加载动态链接器</p>
</li>
<li><p>立即绑定：</p>
<ul>
<li><p>符号解析：解析<strong>可执行文件</strong>和<strong>共享库</strong>中的动态符号表，检查未定义和重复定义错误</p>
</li>
<li><p>重定位：根据<strong>动态重定位表</strong>，对程序中的符号引用进行修正</p>
</li>
</ul>
</li>
<li><p>延迟绑定（符号解析和绑定的负担分散到程序的运行过程中，减少了启动时的延迟）：</p>
<ul>
<li><p>初始：PLT 初始指向 GOT，GOT 初始指向 PLT0</p>
</li>
<li><p>初次调用：借助 PLT，GOP，跳转到 PLT0，使用动态链接器解析符号地址，更新 GOT 表</p>
</li>
<li><p>后续调用：后续调用直接使用 GOT 中的地址</p>
</li>
</ul>
</li>
</ol>
<p>在实际的动态链接过程中，立即绑定和延迟绑定可以<strong>结合使用</strong>。部分关键符号可能在加载时立即解析，而其他符号采用延迟绑定。</p>
<h4 id="gdb-用过哪些指令"><a href="#gdb-用过哪些指令" class="headerlink" title="gdb 用过哪些指令"></a>gdb 用过哪些指令</h4><ul>
<li><code>run</code> 指令运行程序</li>
<li><code>breakpoint</code> 打断点</li>
<li><code>countne</code> 让程序继续运行，直到下一个断点</li>
<li><code>print</code> 打印一些变量值</li>
<li><code>backtrace</code> 查看堆栈信息</li>
<li><code>info thread</code> 查看线程</li>
<li><code>thread 1</code> 切换线程</li>
</ul>
<h4 id="uboot-的启动的大致流程"><a href="#uboot-的启动的大致流程" class="headerlink" title="uboot 的启动的大致流程"></a>uboot 的启动的大致流程</h4><ul>
<li>架构级别初始化<ol>
<li>修改 <code>CPSR</code> 寄存器：设为 SVC 特权模式，禁止 IRQ、FIQ；</li>
<li>修改 <code>cp15</code> 协处理器：设置中断<strong>向量表</strong>基地址，禁止 <strong>TLB</strong>、禁止 <strong>data cache</strong> （避免使用陈旧缓存条目）、关闭 <strong>mmu</strong> 等</li>
<li>准备 C 语言运行环境：分配了一片内存空间，从高到底分别为<strong>global data 区</strong>（保存在 r9），<strong>堆区</strong>，<strong>栈区</strong>（保存在 sp）</li>
<li>调用一系列初始函数，这些函数主要完成：<ul>
<li>在 <code>gd</code> 中保存全局变量，如 <strong>uboot</strong> 大小，设备树地址，环境变量等</li>
<li>初始化<strong>串口</strong> 、<strong>终端</strong> 等设备，并开始打印启动信息</li>
<li>初始化 DRAM，并在 DRAM 中为 <strong>页表</strong>、<strong>uboot</strong>、<strong>malloc</strong>、<strong>全局数据（gd）</strong>、<strong>板卡数据（bd）</strong>预留空间，并将这些预留的<strong>DRAM 地址</strong>保存到当前 <strong>gd</strong> 中</li>
<li><strong>重定位</strong>，拷贝<strong>设备树</strong>、<strong>gd</strong> 到新的地址，重定位 uboot，重定位中断向量表，最后在 DRAM 中重新执行架构初始化 (1,2,3 步)</li>
</ul>
</li>
</ol>
</li>
<li>板级初始化<ol>
<li>仍调用一系列初始化函数，主要完成<ul>
<li>使能 D cache、I cache</li>
<li>flash 设备的初始化、输入输出设备的初始化、中断有关的初始化、网卡相关初始化</li>
<li>main_loop，开始命令行操作。</li>
</ul>
</li>
</ol>
</li>
<li>启动内核<ul>
<li>首先根据启动方式，从存放镜像的介质中加载到 DDR。</li>
<li>检查、校验是哪类镜像</li>
<li>传递参数给内核 （使用设备树传参 ）r0 存放第一个参数 <strong>0</strong>、r1 存放第二个参数 <strong>机器 ID</strong>, r2 存放第三个参数 <strong>设备树首地址</strong></li>
<li>运行内核</li>
</ul>
</li>
</ul>
<h4 id="CPU-占用率过高，如何查原因"><a href="#CPU-占用率过高，如何查原因" class="headerlink" title="CPU 占用率过高，如何查原因"></a>CPU 占用率过高，如何查原因</h4><ol>
<li><p>使用 <code>top</code> 命令可以查看系统各个进程的 CPU 使用情况；</p>
</li>
<li><p>找到 CPU 占有率高的进程可以使用 <code>strace -p &lt;pid&gt;</code> 查看进程使用的系统调用；</p>
</li>
<li><p>还可以使用 <code>perf -p &lt;pid&gt; record -g -F &lt;frequent&gt;</code> 生成性能分析报告；使用 <code>perf report -g</code> 查看报告，该报告记录了<strong>热点函数</strong>所占的 CPU 时间，帮助我们找到性能瓶颈。</p>
</li>
<li><p>找到<strong>热点函数</strong>后，</p>
<ul>
<li><p>可以检查该函数使用的<strong>算法</strong>是否合理，是否还有<strong>优化</strong>空间；</p>
</li>
<li><p>检查<strong>数据结构设计</strong>是否合理，例如，涉及<strong>频繁的查找时使用哈希表</strong>，涉及<strong>频繁插入、删除时使用红黑树</strong>等；</p>
</li>
<li><p>函数是否频繁进行<strong>系统调用</strong>（如文件读写、网络操作)，可以考虑使用<strong>零拷贝</strong>、<strong>mmap</strong> 等优化；</p>
</li>
<li><p>如果函数涉及多线程，需要检查<strong>锁竞争</strong>或<strong>线程同步</strong>问题，可以使用 <code>valgrind --tool=helgrind &lt;bin&gt;</code> （配合 gdb 断点，可以检测单个函数）来检查<strong>潜在的数据竞争</strong>，或者使用更细粒度的锁；</p>
</li>
</ul>
</li>
</ol>
<h4 id="内存泄漏如何检查或避免"><a href="#内存泄漏如何检查或避免" class="headerlink" title="内存泄漏如何检查或避免"></a>内存泄漏如何检查或避免</h4><p>什么是内存泄漏？进程<strong>动态申请</strong>的内存空间，在<strong>使用完毕后未释放</strong>。</p>
<p>如何避免：</p>
<ol>
<li>编程时应保持警觉，确保 <code>malloc/free</code> 配对使用；</li>
<li>在 C++ 中，可以使用智能指针（如 <code>std::unique_ptr</code> 和 <code>std::shared_ptr</code> ）来自动管理内存;</li>
<li>在 C++ 中，对象的生命周期由操作系统来管理，故可以使用 <code>RAII</code> 机制管理动态申请的内存资源；</li>
</ol>
<p>如何检测：</p>
<ol>
<li><code>valgrind</code> 是一个内存管理分析工具，可以检测内存泄露、未初始化的内存访问、数组越界等问题。使用命令 <code>valgrind --leak-check=yes ./bin</code> 检测内存泄漏；</li>
<li><code>address_sanitizer</code> 是一个用于检测内存错误的编译器插件，大部分编译器集成了它，编译时使用  <code>-fsanitize=address</code> 选项启用；</li>
</ol>
<h3 id="C-C"><a href="#C-C" class="headerlink" title="C&#x2F;C++"></a>C&#x2F;C++</h3><h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><h4 id="UART-总线协议"><a href="#UART-总线协议" class="headerlink" title="UART 总线协议"></a>UART 总线协议</h4><ul>
<li><strong>概述</strong> ：uart 是一种<strong>硬件</strong> 通信协议，使用 uart 协议可以实现<strong>异步、串行、全双工</strong> 的数据通信（异步–即无需时钟信号）</li>
<li><strong>接口&#x2F;物理层</strong> ：使用 <strong>TX</strong> 接口串行发送数据，<strong>RX</strong> 接口串行接收数据，此外还有一根<strong>接地线</strong> <ul>
<li><img src="https://kqa3yyvhjg0.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2E4ZjIxN2I0YTIxZmYyMzI5NGRjMDA3NmI0NjdjMDhfV0p2b2tlRG5CMEdGOEg0a3ppS1JsNVNVTEpNWkVkOE9fVG9rZW46SkNkZ2JGUkhIb0Z3bjh4Z3JqSGNSNmNIbnZmXzE3MjYyMjA2NjI6MTcyNjIyNDI2Ml9WNA" alt="img"></li>
</ul>
</li>
<li><strong>通信过程&#x2F;协议层</strong> ：<ul>
<li><p>速度：通信双方要在传输开始前约定好<strong>波特率</strong> ，常见的有 9600，19200，115200 等</p>
</li>
<li><p>发送方以 UART 数据包的形式发送数据</p>
</li>
<li><p><img src="https://kqa3yyvhjg0.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDYxZTg0NjUzYTc4Yzg2OWVmMDhlMmRkYTY5YmU4YzZfbTVERDM1MzdwbWRHWTVxSjNUVng3M2d2Z2loczRwQUhfVG9rZW46TDhibGJhc0FGb1VNRDR4aTFwMmNUY29xbm9kXzE3MjYyMjA2NjI6MTcyNjIyNDI2Ml9WNA" alt="img"></p>
</li>
<li><p><strong>空闲</strong> ：不传输数据时，传输数据线上总是保存<strong>高电平</strong>  </p>
</li>
<li><p><strong>起始位</strong>：将电平<strong>拉低</strong> ，并保持一个周期  </p>
</li>
<li><p><strong>数据位</strong> ：<strong>5-8</strong> 位数据位，<strong>低有效位在前，高有效位在后（多字节数据也是如此，类似小端模式）</strong>，低电平表示 0，高电平表示 1</p>
</li>
<li><p><strong>奇偶校验位</strong> ：用于检查数据是否出错  </p>
</li>
<li><p><strong>停止位</strong> ：<strong>1-2</strong> 位，保持高电平以示终止  </p>
</li>
<li><p><img src="https://kqa3yyvhjg0.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2QzYWM3NzhlZWI0MDEzYTEwNWI4MWY1ZThmZDc4MmVfbjIzWjY2SmNMMG5TSlBhYWgwbmVHakhhRVZIMkxxaE1fVG9rZW46RVlUN2JBT1Ywb0JnSDd4MVlzOWNWd3hublRjXzE3MjYyMjA2NjI6MTcyNjIyNDI2Ml9WNA" alt="img"></p>
</li>
</ul>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/07/11/%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6-%E4%BB%8E%E5%BA%94%E7%94%A8%E5%88%B0%E5%86%85%E6%A0%B8/" rel="prev" title="【经典问题】在 Linux 上打开一个字符设备文件会经历哪些过程？">
      <i class="fa fa-chevron-left"></i> 【经典问题】在 Linux 上打开一个字符设备文件会经历哪些过程？
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/08/07/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82signal/" rel="next" title="【Linux内核】深入理解信号处理机制">
      【Linux内核】深入理解信号处理机制 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.</span> <span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81"><span class="nav-number">1.1.</span> <span class="nav-text">用户态和内核态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%80%81%E5%92%8C%E7%94%A8%E6%88%B7%E6%80%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.1.</span> <span class="nav-text">内核态和用户态的区别?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E9%99%B7%E5%85%A5%E5%86%85%E6%A0%B8%E6%80%81"><span class="nav-number">1.1.2.</span> <span class="nav-text">什么时候会陷入内核态?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E8%AE%BF%E9%97%AE%E7%A9%BA%E6%8C%87%E9%92%88%E4%BC%9A%E4%B8%8D%E4%BC%9A%E9%99%B7%E5%85%A5%E5%86%85%E6%A0%B8%E6%80%81%EF%BC%9F"><span class="nav-number">1.1.3.</span> <span class="nav-text">C 访问空指针会不会陷入内核态？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%B7%E9%98%B1%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E4%BF%A1%E5%8F%B7"><span class="nav-number">1.2.</span> <span class="nav-text">陷阱、中断、异常、信号</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%B7%E9%98%B1%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.2.1.</span> <span class="nav-text">陷阱、中断、异常、信号的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%B7%E9%98%B1%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="nav-number">1.2.2.</span> <span class="nav-text">陷阱、中断、异常、信号的处理流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E9%99%B7%E9%98%B1%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E4%BF%A1%E5%8F%B7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">1.2.3.</span> <span class="nav-text">常见的陷阱、中断、异常、信号有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Ctrl-C%E3%80%81Ctrl-Z%E3%80%81kill-%E3%80%81kill-9-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">1.2.4.</span> <span class="nav-text">Ctrl + C、Ctrl + Z、kill 、kill -9 的原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.3.</span> <span class="nav-text">进程与线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.1.</span> <span class="nav-text">进程与线程的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%EF%BC%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="nav-number">1.3.2.</span> <span class="nav-text">线程，进程的上下文切换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%89%E5%8F%8A%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="nav-number">1.3.3.</span> <span class="nav-text">涉及内核线程的上下文切换有什么不同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#switch-to-%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="nav-number">1.3.4.</span> <span class="nav-text">switch_to 函数为什么需要三个参数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">1.4.</span> <span class="nav-text">进程与线程的通信方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6"><span class="nav-number">1.4.1.</span> <span class="nav-text">信号机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-number">1.4.2.</span> <span class="nav-text">匿名管道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-number">1.4.3.</span> <span class="nav-text">命名管道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">1.4.4.</span> <span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-number">1.4.5.</span> <span class="nav-text">共享内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">1.4.6.</span> <span class="nav-text">消息队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97-socket"><span class="nav-number">1.4.7.</span> <span class="nav-text">套接字 socket</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%84%E7%A7%8D-IPC-%E9%80%82%E7%94%A8%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF"><span class="nav-number">1.4.8.</span> <span class="nav-text">各种 IPC 适用什么场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A6%81%E6%B1%82%E8%BF%9B%E7%A8%8B%E5%B4%A9%E6%BA%83%E9%87%8D%E5%90%AF%E5%90%8E%E5%8F%AF%E4%BB%A5%E7%BB%A7%E7%BB%AD%E8%AF%BB%E5%86%99%EF%BC%8C%E8%AF%A5%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1-IPC-%E6%96%B9%E5%BC%8F"><span class="nav-number">1.4.9.</span> <span class="nav-text">要求进程崩溃重启后可以继续读写，该如何设计 IPC 方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E6%80%81"><span class="nav-number">1.5.</span> <span class="nav-text">并发与竞态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%8C%E4%B8%BE%E4%B8%AA%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-number">1.5.1.</span> <span class="nav-text">什么是线程安全，举个不安全的例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.5.2.</span> <span class="nav-text">线程同步的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%E3%80%81%E5%8F%88%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.5.3.</span> <span class="nav-text">何时使用多进程、又何时使用多线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84-error-%E4%BC%9A%E6%9C%89%E9%97%AE%E9%A2%98%E5%90%97"><span class="nav-number">1.5.4.</span> <span class="nav-text">多线程下的 error 会有问题吗</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="nav-number">2.</span> <span class="nav-text">计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E5%8F%B0%E4%B8%BB%E6%9C%BA%E9%97%B4%E7%9A%84-TCP-%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B"><span class="nav-number">2.1.</span> <span class="nav-text">两台主机间的 TCP 通信过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E5%87%BA%E7%8E%B0%E7%BD%91%E9%A1%B5%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">2.2.</span> <span class="nav-text">输入网址到出现网页的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP"><span class="nav-number">2.3.</span> <span class="nav-text">TCP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">2.3.1.</span> <span class="nav-text">TCP 三次握手的过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">2.3.2.</span> <span class="nav-text">TCP 四次挥手的过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-number">2.3.3.</span> <span class="nav-text">TCP 如何进行流量控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">2.3.4.</span> <span class="nav-text">TCP 如何进行拥塞控制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UDP"><span class="nav-number">2.4.</span> <span class="nav-text">UDP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-UDP-%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="nav-number">2.4.1.</span> <span class="nav-text">如何使用 UDP 实现可靠传输</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-v-s-UDP"><span class="nav-number">2.5.</span> <span class="nav-text">TCP v.s.UDP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-%E5%92%8C-DUP-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.5.1.</span> <span class="nav-text">TCP 和 DUP 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UDP-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94-TCP-%E5%BF%AB"><span class="nav-number">2.5.2.</span> <span class="nav-text">UDP 为什么比 TCP 快</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-number">2.6.</span> <span class="nav-text">网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#socket-%E4%B8%AD%E5%90%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%AF%B9%E5%BA%94%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%AA%E4%BA%9B%E8%A1%8C%E4%B8%BA"><span class="nav-number">2.6.1.</span> <span class="nav-text">socket 中各函数，对应客户端和服务器哪些行为</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#socket-%E9%80%9A%E4%BF%A1%E6%97%B6%EF%BC%8C%E8%BF%9B%E7%A8%8B%E5%B4%A9%E6%BA%83%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="nav-number">2.6.2.</span> <span class="nav-text">socket 通信时，进程崩溃会发生什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#socket-%E8%AF%BB%E5%86%99%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%E7%BC%93%E5%86%B2%E5%8C%BA%E7%A9%BA-%E6%BB%A1%E8%BF%98%E6%98%AF%E8%BF%9E%E6%8E%A5%E5%B7%B2%E6%96%AD%E5%BC%80"><span class="nav-number">2.6.3.</span> <span class="nav-text">socket 读写如何区分缓冲区空&#x2F;满还是连接已断开</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll-%E6%AF%94-select-%E9%AB%98%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">2.6.4.</span> <span class="nav-text">epoll 比 select 高效的原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-LT-%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91%EF%BC%8C%E7%9B%91%E5%90%AC%E5%A4%9A%E4%B8%AA%E5%86%99%E4%BA%8B%E4%BB%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%86%99%E5%B0%B1%E7%BB%AA%E5%90%8E-epoll-wait-%E4%B8%8B%E4%B8%80%E6%AC%A1%E4%B8%8D%E8%BF%94%E5%9B%9E"><span class="nav-number">2.6.5.</span> <span class="nav-text">使用 LT 水平触发，监听多个写事件，如何保证写就绪后 epoll_wait 下一次不返回</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E5%81%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.6.6.</span> <span class="nav-text">epoll 为什么使用红黑树做数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E4%BD%BF%E7%94%A8-epoll-%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%B0%83%E7%94%A8-api-%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-number">2.6.7.</span> <span class="nav-text">描述使用 epoll 实现服务端调用 api 的流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sendfile-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">2.6.8.</span> <span class="nav-text">sendfile 系统调用解决的问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C"><span class="nav-number">2.7.</span> <span class="nav-text">程序运行</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#gcc-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="nav-number">2.7.1.</span> <span class="nav-text">gcc 编译过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="nav-number">2.7.2.</span> <span class="nav-text">ELF 文件格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">2.7.3.</span> <span class="nav-text">静态链接的过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">2.7.4.</span> <span class="nav-text">动态链接的过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gdb-%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%E6%8C%87%E4%BB%A4"><span class="nav-number">2.7.5.</span> <span class="nav-text">gdb 用过哪些指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#uboot-%E7%9A%84%E5%90%AF%E5%8A%A8%E7%9A%84%E5%A4%A7%E8%87%B4%E6%B5%81%E7%A8%8B"><span class="nav-number">2.7.6.</span> <span class="nav-text">uboot 的启动的大致流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU-%E5%8D%A0%E7%94%A8%E7%8E%87%E8%BF%87%E9%AB%98%EF%BC%8C%E5%A6%82%E4%BD%95%E6%9F%A5%E5%8E%9F%E5%9B%A0"><span class="nav-number">2.7.7.</span> <span class="nav-text">CPU 占用率过高，如何查原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5%E6%88%96%E9%81%BF%E5%85%8D"><span class="nav-number">2.7.8.</span> <span class="nav-text">内存泄漏如何检查或避免</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-C"><span class="nav-number">2.8.</span> <span class="nav-text">C&#x2F;C++</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.9.</span> <span class="nav-text">通信协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#UART-%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.9.1.</span> <span class="nav-text">UART 总线协议</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="sunhuashan"
      src="/images/avatar.jfif">
  <p class="site-author-name" itemprop="name">sunhuashan</p>
  <div class="site-description" itemprop="description">唯天下之至拙能胜天下之至巧</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
      
      
        <div class="links-of-blogroll motion-element links-of-blogroll-block">
          <div class="links-of-blogroll-title">
            <!-- modify icon to fire by szw -->
            <i class="fa fa-history fa-" aria-hidden="true"></i>
            近期文章
          </div>
          <ul class="links-of-blogroll-list">
            
            
              <li class="recent_posts_li">
                <a href="/" title="" target="_blank"></a>
              </li>
            
              <li class="recent_posts_li">
                <a href="/" title="" target="_blank"></a>
              </li>
            
              <li class="recent_posts_li">
                <a href="/" title="" target="_blank"></a>
              </li>
            
              <li class="recent_posts_li">
                <a href="/" title="" target="_blank"></a>
              </li>
            
              <li class="recent_posts_li">
                <a href="/" title="" target="_blank"></a>
              </li>
            
          </ul>
        </div>
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sunhuashan</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
